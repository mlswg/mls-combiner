{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2025-10-09T01:36:47.076551+00:00",
  "repo": "mlswg/mls-combiner",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 5,
      "id": "I_kwDONZ9R687PQ-mA",
      "title": "\"combiner\" is very confusing in the context of traditional and PQ algorithms",
      "url": "https://github.com/mlswg/mls-combiner/issues/5",
      "state": "OPEN",
      "author": "rohanmahy",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the context of traditional and PQ KEMs and signature algorithms, a \"combiner\" is already strongly associated with a single algorithm which present a single algorithm (ex: a KEM) which combiners both a traditional and a PQ algorithm within a single MLS group. \n\nI suggest \"group hybridizer\".",
      "createdAt": "2025-10-02T12:27:40Z",
      "updatedAt": "2025-10-02T16:15:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "xisentian",
          "authorAssociation": "COLLABORATOR",
          "body": "Very much agree with the sentiment and we do intend to change the name. \n\nAt the last IETF, others suggested 'Flexible Amortized Combiner' and 'MLS Combiner'. We can add 'group hybridizer' to the list for consideration by the WG. ",
          "createdAt": "2025-10-02T16:15:04Z",
          "updatedAt": "2025-10-02T16:15:04Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "I_kwDONZ9R687PUTZZ",
      "title": "Extension updates inconsistent with draft proposal",
      "url": "https://github.com/mlswg/mls-combiner/issues/6",
      "state": "OPEN",
      "author": "bitbltr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I don't believe the section [Extension updates and validation](https://github.com/mlswg/mls-combiner/blob/main/draft-ietf-mls-combiner.md) is consistent with the AppDataUpdate proposal logic outlined in   https://datatracker.ietf.org/doc/draft-ietf-mls-extensions/\n\nPer Section 4.7 of draft-ietf-mls-extensions: \"The application logic returns either an opaque value new_data that will be stored as the new application data for this component, or else an indication that it considers this update invalid.\"\n\nI read this as the AppDataUpdate contains an opaque value that replaces the entire value for that Component ID. Whereas this proposal includes application logic to update just a particular field within the opaque value. This will necessitate special-casing of this data update logic, rather than the consistent behavior of replacing the opaque value.\n\nTo be consistent, the full HPQMLSInfo struct should be contained in the AppDataUpdate for the Component ID.",
      "createdAt": "2025-10-02T16:50:32Z",
      "updatedAt": "2025-10-08T06:18:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't believe that's correct. To purpose of AppDataUpdate as specified in Section 4.7 of the extension draft is exactly to avoid having to send the entire content of the extension. From the second paragraph of said section:\n\n> The AppDataUpdate proposal allows the app_data_dictionary extension to be updated without these costs. Instead of sending the whole value of the extension, it sends only an update, which is interpreted by the application to provide the new content for the app_data_dictionary extension.\n\nThe idea is that the application gets the content of the proposal from which it creates the new content of the extension. If the proposal always contained the complete extension data we wouldn't need any extension logic.\n\nIf course in this particular case we could still decide that we always want to send the whole HPQMLSInfo struct, but that just seems unnecessary. Even sending the PQ epoch is technically unnecessary as it always just increases by one.\n\nThe logic of updating the epoch of HPQMLSInfo is simple enough. Can you help me understand why you'd want to always replace the whole struct?",
          "createdAt": "2025-10-06T06:34:53Z",
          "updatedAt": "2025-10-06T06:34:53Z"
        },
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "I disagree with the level of granularity you're proposing. It would lead to a cardinality explosion of logic for every Component. The way I read it is the app_data_dictionary is a collection of entries, and the AppDataUpdate is a way to update individual entries instead of having to send the entire dictionary collection. You're taking it a step further and trying to update sub-entries within an individual entry, which I believe is untenable and not the intended scope.",
          "createdAt": "2025-10-07T15:31:26Z",
          "updatedAt": "2025-10-07T15:31:26Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I agree that it can be interpreted both ways. Since we're arguing about the content of another draft at this point, I propose we continue the discussion there. I filed an issue in the corresponding GH repo: https://github.com/mlswg/mls-extensions/issues/74",
          "createdAt": "2025-10-08T06:18:34Z",
          "updatedAt": "2025-10-08T06:18:34Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDONZ9R687PU1u4",
      "title": "Secret used in PSK derivation",
      "url": "https://github.com/mlswg/mls-combiner/issues/7",
      "state": "OPEN",
      "author": "xisentian",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Reminder to revisit the use of `epoch_secret` to derive the PSK as it is usually not directly accessible (see PR #3). ",
      "createdAt": "2025-10-02T17:35:10Z",
      "updatedAt": "2025-10-02T17:35:10Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDONZ9R686R86H_",
      "title": "Qualify limited pq-only authenticity",
      "url": "https://github.com/mlswg/mls-combiner/pull/1",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Since the adversary can forge KeyPackages authenticity in PQ-only mode holds only as long as no one is added (or no one joins) or as long as the adversary is passive during the addition process. The current description is correct, but I feel that this is an important qualification.",
      "createdAt": "2025-04-09T13:44:18Z",
      "updatedAt": "2025-04-09T13:51:47Z",
      "baseRepository": "mlswg/mls-combiner",
      "baseRefName": "main",
      "baseRefOid": "ab5f85f32a085db6152ff717aba8f61195e9e2e5",
      "headRepository": "kkohbrok/mls-combiner",
      "headRefName": "konrad/authenticity_details",
      "headRefOid": "dc4b6974c480186c6fcf16a651ddea688854f957",
      "closedAt": "2025-04-09T13:51:47Z",
      "mergedAt": "2025-04-09T13:51:46Z",
      "mergedBy": "br-hale",
      "mergeCommit": {
        "oid": "2e0a44f239b666ce1e4da48944d40d3a25d4caa2"
      },
      "comments": [
        {
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "body": "That is a good clarification point.",
          "createdAt": "2025-04-09T13:47:49Z",
          "updatedAt": "2025-04-09T13:47:49Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONZ9R686kIASp",
          "commit": {
            "abbreviatedOid": "dc4b697"
          },
          "author": "br-hale",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-04-09T13:49:02Z",
          "updatedAt": "2025-04-09T13:49:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 2,
      "id": "PR_kwDONZ9R686noMJf",
      "title": "Update and verify HPQMLSInfo when doing a full commit",
      "url": "https://github.com/mlswg/mls-combiner/pull/2",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-09T14:55:30Z",
      "updatedAt": "2025-10-01T14:34:13Z",
      "baseRepository": "mlswg/mls-combiner",
      "baseRefName": "main",
      "baseRefOid": "ad18d6a7d6df44bf66d72a59c835db87af414f9e",
      "headRepository": "kkohbrok/mls-combiner",
      "headRefName": "konrad/extension_update",
      "headRefOid": "b104e2b22881867c4ca13dcac998bf8e07ab22b4",
      "closedAt": "2025-10-01T14:34:13Z",
      "mergedAt": "2025-10-01T14:34:13Z",
      "mergedBy": "br-hale",
      "mergeCommit": {
        "oid": "ad7aa13be027f1b88a9f80dcc0780594c2411399"
      },
      "comments": [
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "I implemented this by adding the HPQMLSInfo struct as a GroupInfo extension to both commit messages, just like an external join. Does that suffice without creating new payload types?",
          "createdAt": "2025-09-12T05:27:49Z",
          "updatedAt": "2025-09-12T05:27:49Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm not sure I understand. Commit messages don't carry GroupInfo extensions. Only GroupInfo and Welcome messages do. The way I understand the (current) MLS extensions draft, AppDataUpdate proposals are the intended way to update GroupContext extensions such as HPQMLSInfo.",
          "createdAt": "2025-09-12T07:30:38Z",
          "updatedAt": "2025-09-12T07:30:38Z"
        },
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "I'm going to re-read the MLS extensions draft and make sure I'm handling the struct correctly",
          "createdAt": "2025-09-12T17:47:02Z",
          "updatedAt": "2025-09-12T17:54:11Z"
        },
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "I'm sending the HPQMLS info as both a GroupContextExtensions proposal and in the GroupInfo for welcome messages. So it works out. But using an AppDataUpdate proposal as you have proposed is more efficient than a GroupContextExtensions proposal. With that said, why would you not just include the entire HPQMLSInfo struct in the update? It's small enough, and would future-proof any updates to the struct",
          "createdAt": "2025-09-12T19:43:22Z",
          "updatedAt": "2025-09-12T19:43:22Z"
        },
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "And now that I think about it, using both group context and group info extensions is redundant",
          "createdAt": "2025-09-12T20:13:48Z",
          "updatedAt": "2025-09-12T20:13:48Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd prefer to just send the update, but it's not a strong opinion. If you send the whole thing you have to check the static fields everey time to make sure that everything is consistent. That feels like an unnecessary footgun to me. While this document is still a draft, updates are to be expected anyway. I don't think it's really worth making concessions for an update path.",
          "createdAt": "2025-09-15T06:53:46Z",
          "updatedAt": "2025-09-15T06:53:46Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 3,
      "id": "PR_kwDONZ9R686nwu-S",
      "title": "Describe how PSK and PSK ID are derived",
      "url": "https://github.com/mlswg/mls-combiner/pull/3",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-10T08:04:25Z",
      "updatedAt": "2025-10-02T17:33:03Z",
      "baseRepository": "mlswg/mls-combiner",
      "baseRefName": "main",
      "baseRefOid": "ad7aa13be027f1b88a9f80dcc0780594c2411399",
      "headRepository": "kkohbrok/mls-combiner",
      "headRefName": "konrad/psk_id",
      "headRefOid": "41080422183a213e2f79f12488c95c7276f14933",
      "closedAt": "2025-10-02T16:42:32Z",
      "mergedAt": "2025-10-02T16:42:32Z",
      "mergedBy": "xisentian",
      "mergeCommit": {
        "oid": "c9d30d3c581e28f2ec3db21f2637f2e43132e8d7"
      },
      "comments": [
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "This confused me as well. I had to review and compare previous versions of I-D.ietf-mls-extensions for my current understanding. My implementation is as follows:\r\n\r\n1. The hpqmls_psk exporter key is derived from the epoch_secret on the PQ group, just like all the secrets in Section 8 of RFC 9420 (as labeled DeriveSecret). It is also considered consumed and deleted once used\r\n2. The PSK ID, however, is generated using the SafeExportSecret on the traditional group (using ExtensionType HPQMLS), and encoded as an \"application\" PSK as described in Section 4.5 of I-D.ietf-mls-extension\r\n\r\nThe current draft is confusing, but I believe this implements the intent of the spec.",
          "createdAt": "2025-09-12T05:48:03Z",
          "updatedAt": "2025-09-12T05:48:03Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, I think the current version of this draft is essentially referencing an earlier version of MLS extensions. With this PR I try to update the draft to match the new safe extension interface provided by the current version of the MLS extensions document. Concretely, I don't see a reason to derive from the epoch secret directly, as we can achieve the same security guarantees by using SafeExportSecret. Also, I don't believe MLS implementations will provide public access to the epoch secret or a function to derive secrets from it directly.\r\n\r\nI went ahead and added a note mandating the deletion of `hpqmls_exporter` to ensure we get the desired FS guarantees.",
          "createdAt": "2025-09-12T07:27:43Z",
          "updatedAt": "2025-09-12T07:27:43Z"
        },
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "Either way, I don't think your flow is correct (or maybe I'm reading your flow incorrectly). The PSK ID is not key material. The PSK ID is completely separate and is more like a verifier of state. I derive it from the traditional session because I create a PSK proposal and add it to the commit on the traditional session. I did that because I felt the recipient traditional session needed to be able to generate and verify the PSK ID without introspection into the PQ session. I would love feedback as to whether you think that is correct.",
          "createdAt": "2025-09-12T17:48:52Z",
          "updatedAt": "2025-09-12T18:03:33Z"
        },
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "After re-reading the draft proposal, I was incorrect and do need to generate the PSK ID from the PQ session using SafeExportSecret (not the traditional session) but I still believe the PSK ID is not used to derive the PSK in the flow. The reason I derived the PSK directly from the epoch_secret is because the DeriveExtensionSecret/DeriveApplicationSecret mechanism has been removed from the latest draft of MLS extensions. So I believe we may need some direction from the author.",
          "createdAt": "2025-09-12T19:18:33Z",
          "updatedAt": "2025-09-12T19:32:45Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't have a strong opinion on how to derive the PSK ID. It just seemed convenient to derive the PSK and its ID from the same (FS) secret. Functionally it shouldn't matter much, as you rightfully point out that the PSK ID is just an administrative identifier that the group members just need to agree on. Maybe the authors want to weigh in here.",
          "createdAt": "2025-09-15T06:58:04Z",
          "updatedAt": "2025-09-15T06:58:04Z"
        },
        {
          "author": "xisentian",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that the PSK should be derived from a secret other than `epoch_secret` too - commenting here as a reminder to address this. ",
          "createdAt": "2025-10-02T17:33:03Z",
          "updatedAt": "2025-10-02T17:33:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONZ9R687Ea-dw",
          "commit": {
            "abbreviatedOid": "75019d6"
          },
          "author": "xisentian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Agree with changes, the nomenclature used to describe PSK generation is based on an older version of MLS Safe Extensions draft. ",
          "createdAt": "2025-10-02T16:23:51Z",
          "updatedAt": "2025-10-02T16:23:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 4,
      "id": "PR_kwDONZ9R686nzu1n",
      "title": "Add combined wire formats",
      "url": "https://github.com/mlswg/mls-combiner/pull/4",
      "state": "MERGED",
      "author": "kkohbrok",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2025-09-10T12:33:15Z",
      "updatedAt": "2025-10-01T14:33:36Z",
      "baseRepository": "mlswg/mls-combiner",
      "baseRefName": "main",
      "baseRefOid": "ad18d6a7d6df44bf66d72a59c835db87af414f9e",
      "headRepository": "kkohbrok/mls-combiner",
      "headRefName": "konrad/wire_formats",
      "headRefOid": "769e75313574e6b42d5b820458d027c5706eb52b",
      "closedAt": "2025-10-01T14:33:36Z",
      "mergedAt": "2025-10-01T14:33:36Z",
      "mergedBy": "br-hale",
      "mergeCommit": {
        "oid": "486008198cb19becbf766b0c18d0c95395f52d45"
      },
      "comments": [
        {
          "author": "bitbltr",
          "authorAssociation": "NONE",
          "body": "Based on my own implementation, my opinion is these structures will become inefficient as the tree grows. You're sending the data from both trees to both trees, and while that may simplify the code to keep track of changes, you still have to deliver all the data to both MLS groups. Considering this would only be used for full commits (a relatively low-frequency operation), I feel the existing strategy of separate commits with HPQMLSInfo indicating a need for synchronization is sufficient and keeps the number of wire formats to a minimum",
          "createdAt": "2025-09-12T05:52:44Z",
          "updatedAt": "2025-09-12T05:52:44Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I see what you mean. Traditionally, MLSMessages are for use within one MLS group, while the WireFormats I propose are essentially for use with one combined group. My motivation in creating those structs was my assumption that most implementers will want some combined structs. Also, such structs would be very useful for interoperability. But I suppose they can just exist on their own and don't need to be \"official\" wire formats.",
          "createdAt": "2025-09-12T07:17:00Z",
          "updatedAt": "2025-09-12T07:17:13Z"
        },
        {
          "author": "kkohbrok",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Some more thoughts on combined wire formats: In all likelihood, an application is going to use both single-group messages (e.g. cheaper, traditional-only updates and application messages), as well as combined messages (e.g. full commits). The application will want to transmit both messages over the same channel. If we don't provide a combined wire format for `PrivateMessage` and `PublicMessage`, applications will always have to create their own wrappers to distinguish the two.\r\n\r\nI agree that the other wrappers might not be necessary, but the wrappers around these two message types are very useful for applications.",
          "createdAt": "2025-09-15T08:35:17Z",
          "updatedAt": "2025-09-15T08:35:17Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDONZ9R687DFoT1",
          "commit": {
            "abbreviatedOid": "769e753"
          },
          "author": "xisentian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-26T16:45:24Z",
          "updatedAt": "2025-09-26T16:45:24Z",
          "comments": []
        },
        {
          "id": "PRR_kwDONZ9R687DFpK1",
          "commit": {
            "abbreviatedOid": "769e753"
          },
          "author": "xisentian",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2025-09-26T16:46:30Z",
          "updatedAt": "2025-09-26T16:46:30Z",
          "comments": []
        }
      ]
    }
  ]
}